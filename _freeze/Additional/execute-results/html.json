{
  "hash": "7c0c11b13d57685afaba7f0c85d1dcaa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Additional\"\neditor: visual\noutput:\n  html_document:\n    toc: true\n    toc_float: true\n    number_sections: false\n---\n\n\n\n## 11. Connectedness Maps (grcMalaria-style)\n\n::: callout-note\n### Exercises for 11. Connectedness Maps (based on grcMalaria - <https://genremekong.org/tools/grcmalaria-guide>)\n\n-   What is this figure telling us?\n:::\n\n::: callout-warning\n## Warning\n\nYou may need to zoom into this figure to see the connections.\n:::\n\nHere we define a reusable function to map genetic connectedness between **sites or** countries\\*\\* using the PCoA distance matrix.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_connectedness <- function(meta, dist_mat, group_var = c(\"site\", \"country\"),\n                              measure = c(\"similarity\", \"meanDistance\"),\n                              thresholds = c(0.9, 0.8, 0.7),\n                              min_pairs = 10,\n                              xlim = c(-20, 120),\n                              ylim = c(-25, 25)) {\n\n  group_var <- match.arg(group_var)\n  measure <- match.arg(measure)\n\n  # Ensure order matches distance matrix labels\n  samples <- labels(dist_mat)\n  meta_ord <- meta[match(samples, meta$sample), ]\n  stopifnot(all(meta_ord$sample == samples))\n\n  D <- as.matrix(dist_mat)\n  max_d <- max(D)\n  S <- 1 - D / max_d  # rescaled similarity 0–1\n\n  grp <- meta_ord[[group_var]]\n\n  # Coordinates per group (centroids)\n  centers <- meta_ord %>%\n    group_by(.data[[group_var]]) %>%\n    summarise(lon = mean(longitude),\n              lat = mean(latitude),\n              .groups = \"drop\")\n\n  grp_levels <- centers[[group_var]]\n\n  edges <- list()\n\n  for (i in seq_along(grp_levels)) {\n    for (j in seq_along(grp_levels)) {\n      if (j <= i) next\n      g1 <- grp_levels[i]\n      g2 <- grp_levels[j]\n\n      idx1 <- which(grp == g1)\n      idx2 <- which(grp == g2)\n      if (length(idx1) == 0 || length(idx2) == 0) next\n\n      # all pairwise combinations between groups\n      pairs <- expand.grid(i = idx1, j = idx2)\n      if (nrow(pairs) < min_pairs) next\n\n      d_vals <- D[cbind(pairs$i, pairs$j)]\n      s_vals <- S[cbind(pairs$i, pairs$j)]\n\n      for (thr in thresholds) {\n        if (measure == \"similarity\") {\n          prop <- mean(s_vals >= thr)\n        } else { # meanDistance-style: high similarity ~ low distance\n          # interpret threshold as similarity, convert to distance cutoff\n          d_cutoff <- (1 - thr) * max_d\n          prop <- mean(d_vals <= d_cutoff)\n        }\n        if (prop > 0) {\n          edges[[length(edges) + 1]] <- data.frame(\n            g1 = g1, g2 = g2,\n            lon1 = centers$lon[centers[[group_var]] == g1],\n            lat1 = centers$lat[centers[[group_var]] == g1],\n            lon2 = centers$lon[centers[[group_var]] == g2],\n            lat2 = centers$lat[centers[[group_var]] == g2],\n            prop = prop,\n            threshold = thr,\n            stringsAsFactors = FALSE\n          )\n        }\n      }\n    }\n  }\n\n  if (length(edges) == 0) {\n    message(\"No edges above thresholds.\")\n    return(NULL)\n  }\n\n  edges_df <- do.call(rbind, edges)\n  edges_df$threshold_lab <- paste0(\"Threshold = \", edges_df$threshold)\n\n  world <- ne_countries(scale = \"medium\", returnclass = \"sf\")\n\n  p <- ggplot() +\n    geom_sf(data = world, fill = \"grey95\", color = \"grey80\") +\n    geom_segment(data = edges_df,\n                 aes(x = lon1, y = lat1,\n                     xend = lon2, yend = lat2,\n                     size = prop, color = prop),\n                 alpha = 0.8) +\n    geom_point(data = centers,\n               aes(x = lon, y = lat),\n               size = 2, color = \"black\") +\n   # geom_label(data = centers,\n  #             aes(x = lon, y = lat, label = .data[[group_var]]),\n  #             size = 3, label.size = 0.1, fill = \"white\", alpha = 0.8) +\n    coord_sf(xlim = xlim, ylim = ylim, expand = FALSE) +\n    scale_size_continuous(range = c(0.2, 2.5)) +\n    scale_color_viridis_c() +\n    facet_wrap(~ threshold_lab) +\n    theme_minimal() +\n    labs(title = paste(\"Genetic connectedness by\", group_var),\n         x = \"Longitude\", y = \"Latitude\",\n         size = \"Proportion\nhighly similar pairs\",\n         color = \"Proportion\nhighly similar pairs\")\n\n  p\n}\n```\n:::\n\n\n### 11.1. Connectedness between sites\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Use the same distance matrix from PCoA (dist_mat)\np_site <- map_connectedness(meta, dist_mat_all,\n                            group_var = \"site\",\n                            measure = \"similarity\",\n                            thresholds = c(0.9, 0.8, 0.7),\n                            min_pairs = 10)\n```\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Click to see plot\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Additional_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n:::\n\n:::\n\n## 12. Discriminant Analysis of Principal Components (DAPC)\n\n::: callout-note\n### Exercises for Section 12.\n\n-   What patterns do you observe in this section?\n-   Which samples or populations stand out?\n-   What does this tell you about the outbreak or population structure?\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NOTE: find.clusters() is interactive; this chunk is set to eval=FALSE for knitting.\n# You can run it interactively in an R session.\n\ngrp <- find.clusters(gl_all, max.n.clust = 10)  # interactive prompt for choosing K\ndapc_res <- dapc(gl_all, grp$grp)\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndapc <- dapc(gl_all, n.pca=30, n.da=4)\n\nscatterplot <- scatter(dapc, scree.da=FALSE, scree.pca=FALSE,\ncell=1.5, cex=4, solid=0.8, bg=\"white\",cstar=0, clab=0, leg=TRUE)\n```\n\n::: {.cell-output-display}\n![](Additional_files/figure-html/dpac_site-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# density plots\ndensity <- scatter(dapc,1,1,  bg=\"white\",\nscree.da=FALSE, legend=TRUE, solid=0.9)\n```\n\n::: {.cell-output-display}\n![](Additional_files/figure-html/dpac_site-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# membership probability\nmembership <- compoplot(dapc, lab=\"\", posi=list(x=100,y=-.03), cleg=.7)\n```\n\n::: {.cell-output-display}\n![](Additional_files/figure-html/dpac_site-3.png){width=672}\n:::\n:::\n\n\n\n\n## **What is DAPC?**\n\n-   DAPC = Discriminant Analysis of Principal Components, implemented in *adegenet*.\n\n-   It is a multivariate clustering method specifically designed for genetic data.\n\n-   It works in two steps:\n\n    <div>\n\n    1.  PCA step → reduces dimensionality and removes linkage between loci\n    2.  Discriminant Analysis step → maximises separation among predefined groups\n\n    </div>\n\n## **Why you might choose DAPC over PCoA**\n\n### **1. DAPC explicitly maximises between-group differences**\n\n-   PCoA is *unsupervised* → it reduces the entire distance matrix in a neutral way.\n\n-   DAPC is *supervised* → you specify group labels (e.g., country, site, outbreak cluster).\n\n-   This allows DAPC to highlight **the separation you care about**, even if subtle.\n\n### **2. DAPC is more powerful for detecting population structure**\n\n-   DAPC often reveals clusters missed by PCA/PCoA.\n\n-   Particularly useful for:\n\n    -   detecting cryptic population structure\n\n    -   separating closely related subpopulations\n\n    -   identifying outbreak clusters vs. background diversity\n\n### **3. DAPC is not constrained by assumptions of Hardy–Weinberg equilibrium**\n\n-   Many traditional population genetic methods assume HWE.\n\n-   **DAPC does not**, making it suitable for:\n\n    -   mixed infections\n\n    -   clonally expanding outbreaks\n\n    -   organisms with unusual inheritance (e.g., malaria parasites)\n\n### **4. DAPC works well when the goal is *assignment or classification***\n\n-   You can classify individuals into:\n\n    -   countries\n\n    -   sites\n\n    -   haplotypes\n\n    -   outbreak vs. non-outbreak lineages\n\n-   It also provides **posterior membership probabilities**, helpful for detecting:\n\n    -   imports\n\n    -   admixture\n\n    -   migration events\n\n### **5. DAPC allows flexible selection of PCs**\n\n-   You can tune the number of PCs to:\n\n    -   avoid overfitting\n\n    -   ensure robust structure inference\n\n-   Tools like `xvalDapc()` help you identify the optimal number.\n\n## **Weaknesses of DAPC**\n\n-   **Requires predefined groups** — PCoA does not.\\\n    (Although `find.clusters()` can infer groups first.)\n\n-   **Can overfit** if too many PCs are retained.\n\n-   **Not a true evolutionary model** — separation is statistical, not phylogenetic.\n\n-   **Less intuitive** for beginners compared with PCA/PCoA.\n\n## When to use PcoA vs DAPC?\n\nPCoA shows the structure that exists naturally; DAPC shows the structure you are specifically looking for.\n\nPCoA asks: “How different are all these samples?” DAPC asks: “How different are these groups?”\n",
    "supporting": [
      "Additional_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}